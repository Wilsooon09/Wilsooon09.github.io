---
layout: post
title: Linux内核学习-CFS调度器
---

### Motivation
proj291需要给Linux设计一个新的调度器，故学习一下优秀的CFS调度器是怎么实现的

### Note

CFS（完全公平调度器）的主要流程调用：
1. **初始化**：在系统启动时，初始化 CFS 调度器相关数据结构和参数。
2. **进程创建**：当一个新进程被创建时，为其分配调度实体 `struct sched_entity`，并初始化相关属性。
3. **进程插入调度队列**：通过调用 `enqueue_task_fair()` 函数，将进程插入 CFS 调度队列中，并更新调度信息。
4. **选择下一个运行进程**：在每个时钟中断时，调用 `pick_next_task_fair()` 函数选择下一个应该运行的进程。
5. **上下文切换**：如果选定的进程与当前正在运行的进程不同，则进行上下文切换，将 CPU 分配给新的进程。
6. **时间片耗尽**：当当前运行进程的时间片耗尽时，调用 `put_prev_task_fair()` 函数更新运行进程的虚拟运行时间，并重新插入调度队列。
7. **进程退出或挂起**：当一个进程退出或被挂起时，调用 `dequeue_task_fair()` 函数将其从调度队列中移除。
8. **时钟中断处理**：在每个时钟中断处理程序中，调用 `task_tick_fair()` 函数更新当前运行进程的虚拟运行时间，并检查是否需要进行调度决策。
9. **负载均衡**：定期进行负载均衡，调用相关的负载均衡函数，如 `load_balance()`，以确保各个 CPU 上的任务分布均衡。
10. **循环调度**：重复执行步骤 4-9，不断选择下一个运行进程并进行调度，以实现公平的 CPU 时间片分配。


> 虚拟运行时间 = 实际运行时间 * NICE_0_LOAD / 该任务的权重


### Reference

1. [Linux 进程调度 -CFS 调度器（Linux内核源码分析） - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/677657807)
2. ...
